<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Binary">
<title>Binary</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script 
src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBNjg2ZqtsUmoXcMq-guhJAPwY9lIUNPkI&libraries=places"
async defer>
</script>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect } = React;

// === SVG icons ===
const ThumbsUp = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M7 10v12"/><path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"/></svg>;
const ThumbsDown = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 14V2"/><path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"/></svg>;
const Mic = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>;
const List = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>;
const Trash2 = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>;
const Filter = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>;
const MessageSquare = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>;

// === Master category list ===
const ALL_CATEGORIES = [
'Food', 'Coffee', 'Beverages', 'Places', 'Books', 'Movies',
'Cheese', 'Dates', 'People', 'Sports', 'Entertainment', 'Other'
];

// === Smart category detection ===
// In-memory cache for previously detected categories
const categoryCache = {}; // text -> { category, confidence }

const ALL_CATEGORIES = ['Food', 'Coffee', 'Beverages', 'Places', 'Books', 'Movies', 'Things', 'Other'];

// Keyword fallbacks for categories
const CATEGORY_KEYWORDS = {
  Food: ["restaurant","cheese","ramen","blueberry","pizza","bread","fruit","food","snack","dinner","lunch","breakfast","meal"],
  Coffee: ["coffee","cafe","latte","espresso","cappuccino","americano"],
  Beverages: ["bar","pub","cocktail","brewery","beer","wine"],
  Places: ["museum","park","beach","city","town","venue","holiday","trip","vacation","tourist_attraction"],
  Things: ["shoes","bike","sneakers","sponges","jacket","laptop","bag","phone","watch","bike","sneakers","runners"],
};

// Helper: compute distance in km between two lat/lng points
function distanceKm(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// Main detection function
async function detectCategory(inputText, userLat, userLng) {
const text = inputText.trim();
const lower = text.toLowerCase();
const isCapitalised = /^[A-Z]/.test(text);
  const confidence = { Books: 0, Movies: 0, Places: 0, Food: 0, Other: 0 };
  let placeDistance = null;
  let isFoodPlaceNearby = false;
  let isGenericPlaceNearby = false;

  // ---- 1️⃣ Google Books ----
  // Check cache first
  if (categoryCache[text]) return categoryCache[text];

  // Initialize confidence for all categories
  const confidence = {};
  ALL_CATEGORIES.forEach(cat => confidence[cat] = 0);

  // --------------------
  // 1️⃣ Google Books API
  // --------------------
try {
const bookRes = await fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(text)}&maxResults=3`);
const bookData = await bookRes.json();
if (bookData.items && bookData.items.length > 0) {
      const exact = bookData.items.find(b =>
        b.volumeInfo.title.toLowerCase() === lower
      );
      const exact = bookData.items.find(b => b.volumeInfo.title.toLowerCase() === lower);
confidence.Books = exact ? 0.9 : 0.6;
      if (isCapitalised) confidence.Books += 0.2;
      if (isCapitalised) confidence.Books += 0.2; // capitalization boost ONLY for Books
}
  } catch (err) {
    console.warn("Books API failed:", err);
  }
  } catch(err){ console.warn("Books API failed:", err); }

  // ---- 2️⃣ TMDB Movies ----
  // --------------------
  // 2️⃣ TMDB Movies API
  // --------------------
try {
    const movieRes = await fetch(`https://api.themoviedb.org/3/search/movie?api_key=YOUR_TMDB_KEY&query=${encodeURIComponent(text)}`);
    const tmdbKey = 'YOUR_TMDB_KEY';
    const movieRes = await fetch(`https://api.themoviedb.org/3/search/movie?api_key=${tmdbKey}&query=${encodeURIComponent(text)}`);
const movieData = await movieRes.json();
if (movieData.results && movieData.results.length > 0) {
const exact = movieData.results.find(m => m.title.toLowerCase() === lower);
confidence.Movies = exact ? 0.9 : 0.6;
      if (isCapitalised) confidence.Movies += 0.2;
      if (isCapitalised) confidence.Movies += 0.2; // capitalization boost ONLY for Movies
}
  } catch (err) {
    console.warn("Movies API failed:", err);
  }

// --- Google Places detection ---
if (window.google && window.google.maps) {
  try {
    const placeCat = await new Promise(resolve => {
      const service = new google.maps.places.AutocompleteService();
      service.getPlacePredictions(
        { input: text, types: ['establishment'] },
        (predictions, status) => {
          if (status !== google.maps.places.PlacesServiceStatus.OK || !predictions?.length)
            return resolve(null);

          const first = predictions[0];
          const detailsService = new google.maps.places.PlacesService(document.createElement('div'));
          detailsService.getDetails({ placeId: first.place_id, fields: ['types', 'geometry'] },
            (place, detailsStatus) => {
              if (detailsStatus === google.maps.places.PlacesServiceStatus.OK && place?.types) {
                let distKm = 999;
                let nearbyBoost = 0;

                if (userLat && userLng && place.geometry?.location) {
                  const R = 6371; // Earth radius in km
                  const dLat = (place.geometry.location.lat() - userLat) * Math.PI / 180;
                  const dLng = (place.geometry.location.lng() - userLng) * Math.PI / 180;
                  const a = Math.sin(dLat/2)**2 + Math.cos(userLat*Math.PI/180) * Math.cos(place.geometry.location.lat()*Math.PI/180) * Math.sin(dLng/2)**2;
                  distKm = 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                  if (distKm < 5) nearbyBoost = 0.2; // within 5 km
  } catch(err){ console.warn("Movies API failed:", err); }

  // --------------------
  // 3️⃣ Google Places API
  // --------------------
  if (window.google && window.google.maps) {
    try {
      const placeCat = await new Promise(resolve => {
        const service = new google.maps.places.AutocompleteService();
        service.getPlacePredictions({ input: text, types: ['establishment'] },
          (predictions, status) => {
            if (status !== google.maps.places.PlacesServiceStatus.OK || !predictions?.length)
              return resolve(null);

            const first = predictions[0];
            const detailsService = new google.maps.places.PlacesService(document.createElement('div'));
            detailsService.getDetails({ placeId: first.place_id, fields: ['types','geometry'] },
              (place, detailsStatus) => {
                if (detailsStatus === google.maps.places.PlacesServiceStatus.OK && place?.types) {
                  let nearbyBoost = 0;
                  let distKm = 999;

                  if (userLat && userLng && place.geometry?.location) {
                    distKm = distanceKm(userLat, userLng, place.geometry.location.lat(), place.geometry.location.lng());
                    if (distKm < 5) nearbyBoost = 0.2;
                  }

                  // Map Google types to categories
                  const typeMap = {
                    cafe: 'Coffee',
                    bar: 'Beverages',
                    pub: 'Beverages',
                    restaurant: 'Food',
                  };
                  let baseCat = null;
                  for (let t of place.types) {
                    if (typeMap[t]) { baseCat = typeMap[t]; break; }
                  }
                  if (!baseCat && place.types.some(t => ['park','museum','tourist_attraction','point_of_interest','establishment'].includes(t)))
                    baseCat = 'Places';

                  if (baseCat) confidence[baseCat] = Math.max(confidence[baseCat], 0.6 + nearbyBoost);
}
                resolve(null);
              });
          });
      });
    } catch(err){ console.warn("Places detection failed:", err); }
  }

                let baseCat = null;
                if (place.types.includes('cafe')) baseCat = 'Coffee';
                else if (place.types.includes('bar') || place.types.includes('pub')) baseCat = 'Beverages';
                else if (place.types.includes('restaurant')) baseCat = 'Food';
                else if (place.types.some(t => ['park','museum','tourist_attraction','point_of_interest','establishment'].includes(t)))
                  baseCat = 'Places';

                if (baseCat) {
                  resolve({ category: baseCat, confidence: 0.6 + nearbyBoost });
                } else {
                  resolve(null);
                }
              } else resolve(null);
            }
          );
        }
      );
    });

    if (placeCat) return placeCat.category;
  } catch (err) {
    console.warn('Places detection failed', err);
  // --------------------
  // 4️⃣ Keyword fallback
  // --------------------
  for (const [cat, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
    if (keywords.some(k => lower.includes(k))) {
      confidence[cat] = Math.max(confidence[cat], 0.5);
    }
}
}
    
 // --- Fallback keyword check for generic foods ---
const foodKeywords = ["restaurant", "cheese", "ramen", "blueberry", "coffee", "pizza", "bread", "fruit", "food", "snack"];
if (foodKeywords.some(k => lower.includes(k)) && !confidence.Food) {
  confidence.Food = 0.5;

  // --------------------
  // 5️⃣ Select final category
  // --------------------
  const sorted = Object.entries(confidence).sort((a,b) => b[1]-a[1]);
  let [bestCat, bestScore] = sorted[0];
  if (bestScore < 0.4) bestCat = 'Other';
  const result = { category: bestCat, confidence: bestScore.toFixed(2), confidenceMap: confidence };

  // Cache result
  categoryCache[text] = result;
  return result;
}

// === Main App ===
